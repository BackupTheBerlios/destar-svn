# -*- coding: iso-latin-1 -*-
#
# Copyright (C) 2004 by Holger Schurig
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#


from Templates import *
from quixote.form2 import *
import backend
import types, string


class ROStringWidget(StringWidget):
	"""Widget for output of a simple read-only string
	"""

	def render_content(self):
		return htmltext(self.value)


class LabelWidget(Widget):
	"""Widget for output of a simple label, useful for grouping.
	"""

	def render_content(self):
		"""We only render a <br> for the content because the
		inherited render_title already rendered the title for us."""

		return htmltext('<br />')


def configletsForm (request, obj, title, exitPath="..", actionCallback=None, new=False, menu=None):
	"""This is the class that dynamically create the web forms to edit
	configlets.

	'request' is the http-request from Quixote.
	'obj' is the configlet we're editing.
	'title' is the title of the form.
	'exitPath' is the URL we're visiting when the user presses CANCEL or SUBMIT/UPDATE.
	'actionCallback' is a callable that get's executed after the configlet has been saved.
	'new': is True if we create a new object, False if we're just editing an object.
	'menu': is the menu on the left side."""
	

	def render_desc():
		"""Just renders the description. Substitutes an empty line
		with a <p> paragraph marker."""

		try:
			return htmltext('<p>%s</p>' % obj.description.replace("\n\n","</p><p>"))
		except:
			return None


	def render [html] ():
		header(title, menu)
		render_desc()
		form.render()
		footer()


	def saveConfig(withCallback=True):
		"""Saves all values from the form into the configlet 'obj'."""

		#print "action", obj
		for v in obj.variables:
			if v.hide:
				continue
			_v = form[v.name]
			#print "0", _v, v.name, v.type
			if v.type=="bool" and not _v:
				_v = False
			elif v.type=="string" and _v==None:
				_v = ""
			elif type(_v) == types.ListType:
				_v = ','.join(_v)
			#print 1,_v
			obj.__dict__[v.name] = _v
		if withCallback and actionCallback:
			actionCallback(obj)
			

	def checkConfig():
		"""Can be used to check the configuration. This is done by temporarily
		storing the form values into the object, calling the checkConfig()
		method of the configlet and setting any errors. Then we restore the
		object."""

		backup = copy.copy(obj.__dict__)
		saveConfig(False)
		ret = obj.checkConfig()
		if ret:
			form.set_error(ret[0],ret[1])
		obj.__dict__ = backup


	form = Form()

	if request.form.has_key('_cancel'):
		print "-->cancel"
		return request.redirect(exitPath)
	if request.form.has_key('_delete'):
		print "-->delete"
		backend.deleteConfiglet(obj._id)
		return request.redirect(exitPath)


	do_update = False
	for v in obj.variables:
		if v.hide:
			continue
		try:
			_v = obj.__dict__[v.name]
		except:
			_v = ''
		if _v: do_update = True
		t = htmltext(v.title)
		r = not v.optional
		if v.type=="string":
			form.add(StringWidget, v.name, _v, t, v.hint, r, False, maxlength=v.len, size=min(v.size,56) )
		elif v.type=="text":
			form.add(TextWidget,   v.name, _v, t, v.hint, r, False, rows=v.__dict__.setdefault("rows",8), cols=v.__dict__.setdefault("cols",65) )
		elif v.type=="choice":
			if not v.__dict__.has_key("options"):
				if v.name=="permission":
					v.options = backend.getChoice(clazz="CfgPermDial")
				elif v.name=="phone":
					v.options = backend.getChoice(clazz="CfgPhone")
				elif v.name=="aa":
					v.options = backend.getChoice(clazz="CfgAppAA")
				if v.optional:
					v.options.insert(0, ('',''))
			if not v.options:
				return errorpage(_("Required '%s' not found") % v.name)
			form.add(SingleSelectWidget, v.name, _v, title=t, hint=v.hint, required=r, options=v.options)
		elif v.type=="mchoice":
			# TODO: much of this code should NOT by in a *.ptl file
			if not v.__dict__.has_key("options") and v.name=="include":
				v.options = [('','')]
				for c in backend.getConfiglets(group="CfgPermDeny"):
					try:
						desc = c.desc
					except AttributeError:
						desc = c.context
					v.options.append((c.name,desc))
			if type(_v) == types.StringType:
				_v = map(string.strip, _v.split(','))
			form.add(MultipleSelectWidget, v.name, _v, title=t, hint=v.hint, required=r, options=v.options)
		elif v.type=="int":
			form.add(IntWidget,      v.name, _v, title=t, hint=v.hint, required=r, maxlength=v.len, size=min(v.len,15) )
		elif v.type=="bool":
			form.add(CheckboxWidget, v.name, _v, t, v.hint, r)
		elif v.type=="label":
			form.add(LabelWidget,    v.name, title=t, render_br=False)
		elif v.type=="rostring":
			#form.add(ROStringWidget,    v.name, title=t, render_br=False)
			form.add(ROStringWidget, v.name, _v, t, v.hint, r, False, maxlength=v.len, size=min(v.size,56) )
		else:
			form.add(StringWidget,   v.name, "Unknown type %s" % v.type)
	
	if new or not obj.isAddable():
		txt_submit = _("Submit")
		txt_delete = ""
	else:
		txt_submit = _("Update")
		txt_delete = _("Delete")

	if txt_submit:
		form.add(SubmitWidget, '_submit', txt_submit, render_br=False)
	if txt_delete:
		form.add(SubmitWidget, '_delete', txt_delete, render_br=False)
	form.add(SubmitWidget, '_cancel', _("Cancel"), render_br=False)

	if not form.is_submitted() or form.has_errors():
		return render()
	checkConfig()
	if form.has_errors():
		return render()
	saveConfig()
	obj.fixup()
	return request.redirect(exitPath)



def showConfigFilesThatNeedBackup [plain] (files):
	htmltext(_("""There are some config files from your previous configuration that weren't
	created by DeStar. Click on the links to backup them."""))
	'<ul>'
	for file in files:
		'<li>'
		'<a href="backup/%s">%s</a>' % (file, file)
		'</li>'
	'</ul><p>'
	htmltext(_("Because of this, I did not touch any of you config files"))
	'.</p>'


tipped = False
def configurationTip [plain] (tip, url, label):
	global tipped
	if not tipped:
		'<h2>'
		htmltext(_('Configuration tips'))
		'</h2>'
		'<ul>'
	tipped = True
	'<li>'
	htmltext(_(tip))
	': <a href="%s">' % url
	' -> '.join(label)
	'</a>'
	'</li>'

def configurationTips [plain] (request):
	global tipped
	tipped = False

	if request.session.user=='virtual config user':
		configurationTip(
			_("You should create a user with type 'Configurator'"),
			"add/CfgOptUser",
			[_("Configuration"), _("Edit Options"), _("DeStar user")] )
	if not backend.countConfiglets("Phones"):
		configurationTip(
			_("You should create a phone"),
			"Phones/",
			[_("Configuration"), _("Edit Phones")] )
	if not backend.countConfiglets("Phones"):
		configurationTip(
			_("You should create a telco line"),
			"TelCoLines/",
			[_("Configuration"), _("Edit TelCo Lines")] )
	if not backend.countConfiglets(clazz="CfgOptManager"):
		configurationTip(
			_("You should create a manager entry"),
			"add/CfgOptManager",
			[_("Configuration"), _("Edit Options"), _("Manager access")] )

	if tipped:
		'</ul>'

def showConfigurables [plain] (head):
	'<p>'
	head
	':</p><table id="subcategories">'
	'<tr>'
	for s in (htmltext(_('Configured')), htmltext(_('Category'))):
		'<th>%s</th>' % s
	'</tr>'

	for group in backend.configletsGrouped():
		'<tr>'
		'<td>%s</td>' % backend.countConfiglets(group)
		'<td><a href="%s">%s</a></td>' % (group, _(group))
		'</tr>'
	'</table>'
